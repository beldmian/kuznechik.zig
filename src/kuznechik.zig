const std = @import("std");
const testing = std.testing;

pub const block = @Vector(16, u8);
pub const key = @Vector(32, u8);

fn x_trans(a: block, b: block) block {
    return a ^ b;
}

const pi_table: [256]u8 = .{ 0xFC, 0xEE, 0xDD, 0x11, 0xCF, 0x6E, 0x31, 0x16, 0xFB, 0xC4, 0xFA, 0xDA, 0x23, 0xC5, 0x04, 0x4D, 0xE9, 0x77, 0xF0, 0xDB, 0x93, 0x2E, 0x99, 0xBA, 0x17, 0x36, 0xF1, 0xBB, 0x14, 0xCD, 0x5F, 0xC1, 0xF9, 0x18, 0x65, 0x5A, 0xE2, 0x5C, 0xEF, 0x21, 0x81, 0x1C, 0x3C, 0x42, 0x8B, 0x01, 0x8E, 0x4F, 0x05, 0x84, 0x02, 0xAE, 0xE3, 0x6A, 0x8F, 0xA0, 0x06, 0x0B, 0xED, 0x98, 0x7F, 0xD4, 0xD3, 0x1F, 0xEB, 0x34, 0x2C, 0x51, 0xEA, 0xC8, 0x48, 0xAB, 0xF2, 0x2A, 0x68, 0xA2, 0xFD, 0x3A, 0xCE, 0xCC, 0xB5, 0x70, 0x0E, 0x56, 0x08, 0x0C, 0x76, 0x12, 0xBF, 0x72, 0x13, 0x47, 0x9C, 0xB7, 0x5D, 0x87, 0x15, 0xA1, 0x96, 0x29, 0x10, 0x7B, 0x9A, 0xC7, 0xF3, 0x91, 0x78, 0x6F, 0x9D, 0x9E, 0xB2, 0xB1, 0x32, 0x75, 0x19, 0x3D, 0xFF, 0x35, 0x8A, 0x7E, 0x6D, 0x54, 0xC6, 0x80, 0xC3, 0xBD, 0x0D, 0x57, 0xDF, 0xF5, 0x24, 0xA9, 0x3E, 0xA8, 0x43, 0xC9, 0xD7, 0x79, 0xD6, 0xF6, 0x7C, 0x22, 0xB9, 0x03, 0xE0, 0x0F, 0xEC, 0xDE, 0x7A, 0x94, 0xB0, 0xBC, 0xDC, 0xE8, 0x28, 0x50, 0x4E, 0x33, 0x0A, 0x4A, 0xA7, 0x97, 0x60, 0x73, 0x1E, 0x00, 0x62, 0x44, 0x1A, 0xB8, 0x38, 0x82, 0x64, 0x9F, 0x26, 0x41, 0xAD, 0x45, 0x46, 0x92, 0x27, 0x5E, 0x55, 0x2F, 0x8C, 0xA3, 0xA5, 0x7D, 0x69, 0xD5, 0x95, 0x3B, 0x07, 0x58, 0xB3, 0x40, 0x86, 0xAC, 0x1D, 0xF7, 0x30, 0x37, 0x6B, 0xE4, 0x88, 0xD9, 0xE7, 0x89, 0xE1, 0x1B, 0x83, 0x49, 0x4C, 0x3F, 0xF8, 0xFE, 0x8D, 0x53, 0xAA, 0x90, 0xCA, 0xD8, 0x85, 0x61, 0x20, 0x71, 0x67, 0xA4, 0x2D, 0x2B, 0x09, 0x5B, 0xCB, 0x9B, 0x25, 0xD0, 0xBE, 0xE5, 0x6C, 0x52, 0x59, 0xA6, 0x74, 0xD2, 0xE6, 0xF4, 0xB4, 0xC0, 0xD1, 0x66, 0xAF, 0xC2, 0x39, 0x4B, 0x63, 0xB6 };

const pi_inv_table: [256]u8 = .{ 0xA5, 0x2D, 0x32, 0x8F, 0x0E, 0x30, 0x38, 0xC0, 0x54, 0xE6, 0x9E, 0x39, 0x55, 0x7E, 0x52, 0x91, 0x64, 0x03, 0x57, 0x5A, 0x1C, 0x60, 0x07, 0x18, 0x21, 0x72, 0xA8, 0xD1, 0x29, 0xC6, 0xA4, 0x3F, 0xE0, 0x27, 0x8D, 0x0C, 0x82, 0xEA, 0xAE, 0xB4, 0x9A, 0x63, 0x49, 0xE5, 0x42, 0xE4, 0x15, 0xB7, 0xC8, 0x06, 0x70, 0x9D, 0x41, 0x75, 0x19, 0xC9, 0xAA, 0xFC, 0x4D, 0xBF, 0x2A, 0x73, 0x84, 0xD5, 0xC3, 0xAF, 0x2B, 0x86, 0xA7, 0xB1, 0xB2, 0x5B, 0x46, 0xD3, 0x9F, 0xFD, 0xD4, 0x0F, 0x9C, 0x2F, 0x9B, 0x43, 0xEF, 0xD9, 0x79, 0xB6, 0x53, 0x7F, 0xC1, 0xF0, 0x23, 0xE7, 0x25, 0x5E, 0xB5, 0x1E, 0xA2, 0xDF, 0xA6, 0xFE, 0xAC, 0x22, 0xF9, 0xE2, 0x4A, 0xBC, 0x35, 0xCA, 0xEE, 0x78, 0x05, 0x6B, 0x51, 0xE1, 0x59, 0xA3, 0xF2, 0x71, 0x56, 0x11, 0x6A, 0x89, 0x94, 0x65, 0x8C, 0xBB, 0x77, 0x3C, 0x7B, 0x28, 0xAB, 0xD2, 0x31, 0xDE, 0xC4, 0x5F, 0xCC, 0xCF, 0x76, 0x2C, 0xB8, 0xD8, 0x2E, 0x36, 0xDB, 0x69, 0xB3, 0x14, 0x95, 0xBE, 0x62, 0xA1, 0x3B, 0x16, 0x66, 0xE9, 0x5C, 0x6C, 0x6D, 0xAD, 0x37, 0x61, 0x4B, 0xB9, 0xE3, 0xBA, 0xF1, 0xA0, 0x85, 0x83, 0xDA, 0x47, 0xC5, 0xB0, 0x33, 0xFA, 0x96, 0x6F, 0x6E, 0xC2, 0xF6, 0x50, 0xFF, 0x5D, 0xA9, 0x8E, 0x17, 0x1B, 0x97, 0x7D, 0xEC, 0x58, 0xF7, 0x1F, 0xFB, 0x7C, 0x09, 0x0D, 0x7A, 0x67, 0x45, 0x87, 0xDC, 0xE8, 0x4F, 0x1D, 0x4E, 0x04, 0xEB, 0xF8, 0xF3, 0x3E, 0x3D, 0xBD, 0x8A, 0x88, 0xDD, 0xCD, 0x0B, 0x13, 0x98, 0x02, 0x93, 0x80, 0x90, 0xD0, 0x24, 0x34, 0xCB, 0xED, 0xF4, 0xCE, 0x99, 0x10, 0x44, 0x40, 0x92, 0x3A, 0x01, 0x26, 0x12, 0x1A, 0x48, 0x68, 0xF5, 0x81, 0x8B, 0xC7, 0xD6, 0x20, 0x0A, 0x08, 0x00, 0x4C, 0xD7, 0x74 };

inline fn s_trans(a: block) block {
    var out = a;
    for (0..16) |i| {
        out[i] = pi_table[out[i]];
    }
    return out;
}

fn s_inv_trans(a: block) block {
    var out = a;
    for (0..16) |i| {
        out[i] = pi_inv_table[out[i]];
    }
    return out;
}

fn gf_mul(a_in: u8, b_in: u8) u8 {
    var a: u8 = a_in;
    var b: u8 = b_in;
    var c: u8 = 0;
    for (0..8) |_| {
        if (b & 1 == 1) {
            c = c ^ a;
        }
        if (a & 0x80 == 0x80) {
            a = (a << 1) ^ 0xc3;
        } else {
            a = a << 1;
        }
        b = b >> 1;
    }
    return c;
}

const l_vec: [16]u8 =
    .{ 148, 32, 133, 16, 194, 192, 1, 251, 1, 192, 194, 16, 133, 32, 148, 1 };

fn l_trans(a: block) block {
    var out = a;
    for (0..16) |_| {
        var x = out[15];
        for (0..15) |i| {
            out[(14 - i) + 1] = out[14 - i];
            x ^= gf_mul(out[14 - i], l_vec[14 - i]);
        }
        out[0] = x;
    }
    return out;
}

fn l_inv_trans(a: block) block {
    var out = a;
    for (0..16) |_| {
        var x = out[0];
        for (0..15) |i| {
            out[i] = out[i + 1];
            x ^= gf_mul(out[i], l_vec[i]);
        }
        out[15] = x;
    }
    return out;
}

const ls_trans_lut = lut_blk: {
    @setEvalBranchQuota(100000000);
    var lut: [16][256]block align(4096 * 8) = [_][256]block{[_]block{[_]u8{0} ** 16} ** 256} ** 16;
    for (0..16) |i| {
        for (0..256) |v| {
            var blk = @as(block, @splat(0));
            blk[i] = pi_table[v];
            lut[i][v] = l_trans(blk);
        }
    }
    break :lut_blk lut;
};

const ls_inv_trans_lut = lut_blk: {
    @setEvalBranchQuota(100000000);
    var lut: [16][256]block align(4096 * 8) = [_][256]block{[_]block{[_]u8{0} ** 16} ** 256} ** 16;
    for (0..16) |i| {
        for (0..256) |v| {
            var blk = @as(block, @splat(0));
            blk[i] = pi_inv_table[v];
            lut[i][v] = l_inv_trans(blk);
        }
    }
    break :lut_blk lut;
};

inline fn lsx_trans(a: *block, k: block) void {
    @setRuntimeSafety(false);
    a.* ^= k;
    a.* =
        ls_trans_lut[0][a[0]] ^
        ls_trans_lut[1][a[1]] ^
        ls_trans_lut[2][a[2]] ^
        ls_trans_lut[3][a[3]] ^
        ls_trans_lut[4][a[4]] ^
        ls_trans_lut[5][a[5]] ^
        ls_trans_lut[6][a[6]] ^
        ls_trans_lut[7][a[7]] ^
        ls_trans_lut[8][a[8]] ^
        ls_trans_lut[9][a[9]] ^
        ls_trans_lut[10][a[10]] ^
        ls_trans_lut[11][a[11]] ^
        ls_trans_lut[12][a[12]] ^
        ls_trans_lut[13][a[13]] ^
        ls_trans_lut[14][a[14]] ^
        ls_trans_lut[15][a[15]];
}

inline fn ls_inv_trans(a: *block) void {
    @setRuntimeSafety(false);
    a.* =
        ls_inv_trans_lut[0][a[0]] ^
        ls_inv_trans_lut[1][a[1]] ^
        ls_inv_trans_lut[2][a[2]] ^
        ls_inv_trans_lut[3][a[3]] ^
        ls_inv_trans_lut[4][a[4]] ^
        ls_inv_trans_lut[5][a[5]] ^
        ls_inv_trans_lut[6][a[6]] ^
        ls_inv_trans_lut[7][a[7]] ^
        ls_inv_trans_lut[8][a[8]] ^
        ls_inv_trans_lut[9][a[9]] ^
        ls_inv_trans_lut[10][a[10]] ^
        ls_inv_trans_lut[11][a[11]] ^
        ls_inv_trans_lut[12][a[12]] ^
        ls_inv_trans_lut[13][a[13]] ^
        ls_inv_trans_lut[14][a[14]] ^
        ls_inv_trans_lut[15][a[15]];
}

fn make_iter_c() [32]block {
    var out: [32]block = [_]block{[_]u8{0} ** 16} ** 32;
    for (0..32) |i| {
        var v = [_]u8{0} ** 16;
        v[15] = @intCast(i + 1);
        out[i] = l_trans(v);
    }
    return out;
}

fn f_trans(k1: block, k2: block, iter_c: block) [2]block {
    return [2]block{ x_trans(l_trans(s_trans(x_trans(k1, iter_c))), k2), k1 };
}

fn make_iter_keys(k: key) [10]block {
    @setEvalBranchQuota(1000000);
    var k1: block = @as([32]u8, k)[0..16].*;
    var k2: block = @as([32]u8, k)[16..32].*;
    var iter_keys: [10]block = [_]block{[_]u8{0} ** 16} ** 10;
    const iter_c = comptime make_iter_c();
    iter_keys[0] = k1;
    iter_keys[1] = k2;
    for (0..4) |i| {
        for (0..8) |j| {
            const res = f_trans(k1, k2, iter_c[j + 8 * i]);
            k1 = res[0];
            k2 = res[1];
        }
        iter_keys[2 * i + 2] = k1;
        iter_keys[2 * i + 3] = k2;
    }
    return iter_keys;
}

pub const Cipher = struct {
    k: key,
    ik: [10]block,
    ik_inv: [10]block,

    pub fn init(k: key) Cipher {
        @prefetch(&ls_trans_lut, std.builtin.PrefetchOptions{});
        const ik = make_iter_keys(k);
        var ik_inv = ik;
        for (0..10) |i| {
            ik_inv[i] = l_inv_trans(ik[i]);
        }
        return Cipher{
            .k = k,
            .ik = ik,
            .ik_inv = ik_inv,
        };
    }

    pub fn encrypt(self: Cipher, msg: *block) void {
        @setRuntimeSafety(false);
        inline for (0..9) |i| {
            lsx_trans(msg, self.ik[i]);
        }
        msg.* ^= self.ik[9];
    }
    pub fn decrypt(self: Cipher, msg: *block) void {
        @setRuntimeSafety(false);
        msg.* = s_trans(msg.*);
        inline for (0..9) |i| {
            ls_inv_trans(msg);
            msg.* ^= self.ik_inv[9 - i];
        }
        msg.* = s_inv_trans(msg.*);
        msg.* ^= self.ik[0];
    }
};

test "X transition test" {
    const vect_a = @Vector(16, u8){ 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    const vect_b = @Vector(16, u8){ 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    const vect_out = @Vector(16, u8){ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    try testing.expectEqual(x_trans(vect_a, vect_b), vect_out);
}

test "S and S inverse transition test" {
    const vect_s_test = @Vector(16, u8){ 0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x00 };
    const vect_s_test_out = @Vector(16, u8){ 0xb6, 0x6c, 0xd8, 0x88, 0x7d, 0x38, 0xe8, 0xd7, 0x77, 0x65, 0xae, 0xea, 0x0c, 0x9a, 0x7e, 0xfc };
    try testing.expectEqual(s_trans(vect_s_test), vect_s_test_out);
    try testing.expectEqual(s_inv_trans(vect_s_test_out), vect_s_test);
}

test "L and L inverse transition test" {
    const vect_l_test = @Vector(16, u8){ 0x64, 0xa5, 0x94, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    const vect_l_test_out = @Vector(16, u8){ 0xd4, 0x56, 0x58, 0x4d, 0xd0, 0xe3, 0xe8, 0x4c, 0xc3, 0x16, 0x6e, 0x4b, 0x7f, 0xa2, 0x89, 0x0d };
    try testing.expectEqual(l_trans(vect_l_test), vect_l_test_out);
    try testing.expectEqual(l_inv_trans(vect_l_test_out), vect_l_test);
}

test "LS transition test" {
    var vect_l_test = @Vector(16, u8){ 0x64, 0xa5, 0x94, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    const vect_l_test_copy = @Vector(16, u8){ 0x64, 0xa5, 0x94, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    const vect_zero = @Vector(16, u8){ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    lsx_trans(&vect_l_test, vect_zero);
    try testing.expectEqual(l_trans(s_trans(vect_l_test_copy)), vect_l_test);
}

test "LS inverse transition test" {
    var vect_l_test = @Vector(16, u8){ 0x64, 0xa5, 0x94, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    const vect_l_test_copy = @Vector(16, u8){ 0x64, 0xa5, 0x94, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    ls_inv_trans(&vect_l_test);
    try testing.expectEqual(l_inv_trans(s_inv_trans(vect_l_test_copy)), vect_l_test);
}

test "Iterational constants test" {
    const iter_c_1 = @Vector(16, u8){ 0x6e, 0xa2, 0x76, 0x72, 0x6c, 0x48, 0x7a, 0xb8, 0x5d, 0x27, 0xbd, 0x10, 0xdd, 0x84, 0x94, 0x01 };
    const iter_c_8 = @Vector(16, u8){ 0xf6, 0x59, 0x36, 0x16, 0xe6, 0x05, 0x56, 0x89, 0xad, 0xfb, 0xa1, 0x80, 0x27, 0xaa, 0x2a, 0x08 };
    const iter_c = make_iter_c();
    try testing.expectEqual(iter_c[0], iter_c_1);
    try testing.expectEqual(iter_c[7], iter_c_8);
}

test "Iterational keys test" {
    const k = key{ 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef };
    const iter_keys = make_iter_keys(k);
    const iter_key_1 = block{ 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77 };
    const iter_key_10 = block{ 0x72, 0xe9, 0xdd, 0x74, 0x16, 0xbc, 0xf4, 0x5b, 0x75, 0x5d, 0xba, 0xa8, 0x8e, 0x4a, 0x40, 0x43 };
    try testing.expectEqual(iter_keys[0], iter_key_1);
    try testing.expectEqual(iter_keys[9], iter_key_10);
}

test "Cipher test" {
    const k = key{ 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef };
    const iter_key_1 = block{ 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77 };
    var msg = block{ 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x00, 0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88 };
    const msg_enc = block{ 0x7f, 0x67, 0x9d, 0x90, 0xbe, 0xbc, 0x24, 0x30, 0x5a, 0x46, 0x8d, 0x42, 0xb9, 0xd4, 0xed, 0xcd };
    const msg_dec = block{ 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x00, 0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88 };
    const cipher = Cipher.init(k);
    try testing.expectEqual(cipher.ik[0], iter_key_1);
    try testing.expectEqual(cipher.ik_inv[0], l_inv_trans(iter_key_1));
    cipher.encrypt(&msg);
    try testing.expectEqual(msg_enc, msg);
    cipher.decrypt(&msg);
    try testing.expectEqual(msg_dec, msg);
}
